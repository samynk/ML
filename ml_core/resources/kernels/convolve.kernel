int2 indexToRC(int index, int nrOfRows){
    return (int2)(index%nrOfRows, index/nrOfRows);
}

int3 indexToRCS(int index, int2 dim){
    int slice = index / dim.y;
    int column = (index % dim.y) / dim.x;
    return (int3)(index% dim.x, column, slice);
}

int4 indexToRCSH(int index, int3 dim){
    int hs = index / dim.z;
    int3 rcs = indexToRCS(index%dim.z, dim.xy);
    return (int4)(rcs, hs);
}

int rcToIndex(int row, int column, int nrOfRows){
    return row + column*nrOfRows;
}

int rcsToIndex(int3 rcs, int2 dim){
    return rcs.x + rcs.y*dim.x + rcs.z*dim.y;
}

int rcshToIndex(int4 rcsh, int3 dim){
    return rcsh.x + rcsh.y*dim.x + rcsh.z*dim.y +rcsh.w*dim.z;
}
/*
iDim: x contains number of rows in filter, y contains number of columns
fDim: x contains number of rows in filter, y contains number of columns
oDim: x contains number of rows in filter, y contains number of columns
*/
__kernel void convolution(
    const __global float* input,
    __constant float* filter,
    __global float* output,
    const int2 iDim,
    const int2 fDim,
    const int2 oDim
)
{
    int index = get_global_id(0);
    int2 rc = indexToRC(index, oDim.x);
    int gRow = rc.x;
    int gCol = rc.y;

    float sum = 0;   
    for(int fRow = 0;  fRow < fDim.x; ++fRow){
        int iRow = gRow + fRow;   
        for(int fCol = 0;fCol< fDim.y; ++fCol){
            int iCol = gCol + fCol;
            int inputI = rcToIndex(iRow,iCol,iDim.x);
            int filterI = rcToIndex(fRow,fCol,fDim.x);
            sum += input[inputI] * filter[filterI];
        }
    }
    output[ index ] = sum;
}

/*
iDim: x,y,z -> rowSize, sliceSize, hyperSliceSize
fDim: x,y,  -> rowSize, columnSize
oDim: x,y,z -> rowSize, sliceSize, hyperSliceSize
filterPerInputSlice: how many filters are there per slice of the input.
*/
__kernel void batchConvolution(
    const __global float* input,
    const __global float* filter,
    __global float* output,
    const int3 iDim,
    const int2 fDim,
    const int3 oDim,
    const int fps,
    const int stride
)
{
    int index = get_global_id(0);
    int4 rcsh = indexToRCSH(index, oDim);
    // rcsh.z contains the current filter nr.
    int fSlice = rcsh.z;
    int inputSlice = rcsh.z / fps;
    
    float sum = 0;
    for(int fRow = 0;  fRow < fDim.x; ++fRow){
        int inputRow = rcsh.x + fRow;   
        for(int fCol = 0;fCol < fDim.y; ++fCol){
            int inputCol = rcsh.y + fCol;
            int inputI = rcshToIndex( (int4)( inputRow, inputCol, inputSlice, rcsh.w ) , iDim);
            int filterI = rcsToIndex( (int3) (fRow, fCol, fSlice) , (int2)(fDim.x,fDim.x*fDim.y) );
            sum += input[inputI] * filter[filterI];
        }
    }
    output[ index ] = sum;//rcsh.y;
}

__kernel void batchCorrelate(
    const __global float* input,
    const __global float* filter,
    __global float* output,
    const int3 iDim,
    const int2 fDim,
    const int3 oDim,
    const int fps,
    const int stride
)
{
    int index = get_global_id(0);
    int4 rcsh = indexToRCSH(index, oDim);
    // rcsh.z contains the current filter nr.
    int oRow = rcsh.x * stride;
    int oCol = rcsh.y * stride;
    int oSlice = rcsh.z;
    int oHyperSlice = rcsh.w;
    int fSlice = rcsh.z;
    int inputSlice = rcsh.z / fps;

    float sum = 0;
    for(int fRow = 0;  fRow < fDim.x; ++fRow){
        int inputRow = oRow + fRow;   
        for(int fCol = 0;fCol< fDim.y;++fCol){
            int inputCol = oCol + fCol;
           
            int fColOffset = (fDim.x - fCol - 1);
            int fRowOffset = (fDim.y - fRow - 1);

            int inputI = rcshToIndex( (int4)( inputRow, inputCol, inputSlice, oHyperSlice ) , iDim);
            int filterI = rcsToIndex( (int3) (fRow, fCol, fSlice) , (int2)(fDim.x,fDim.x*fDim.y) );
            sum += input[inputI] * filter[filterI];
        }
    }
    output[ index ] = sum;
}

__kernel void batchBackpropCorrelate(
    const __global float* input,
    const __global float* filter,
    __global float* output,
    const int3 iDim,
    const int2 fDim,
    const int3 oDim,
    const int fps,
    const int stride
)
{
    int index = get_global_id(0);
    int4 rcsh = indexToRCSH(index, oDim);
    // rcsh.z contains the current filter nr.
    int oRow = rcsh.x * stride;
    int oCol = rcsh.y * stride;
    int oSlice = rcsh.z;
    int oHyperSlice = rcsh.w;
    int fSliceOffset = rcsh.z * fps;
    int iSliceOffset = rcsh.z * fps;

    float sum = 0;
    for(int iSlice = 0; iSlice < fps; ++iSlice){
        for(int fRow = 0;  fRow < fDim.x; ++fRow){
            int inputRow = oRow + fRow;   
            for(int fCol = 0;fCol< fDim.y;++fCol){
                int inputCol = oCol + fCol;
                int inputI = rcshToIndex( (int4)( inputRow, inputCol, iSliceOffset+iSlice, oHyperSlice ) , iDim);
                int fColOffset = (fDim.y - fCol - 1);
                int fRowOffset = (fDim.x - fRow - 1);
                int filterI = rcsToIndex( (int3) (fRowOffset, fColOffset, fSliceOffset+iSlice) , (int2)(fDim.x,fDim.x*fDim.y) );
                sum += input[inputI] * filter[filterI];
               
            }
        }
    }
    output[index] = sum;
}

float2 getFilterValue( const __constant float* filter, int x, int y,int fSlice,  int2 fDim)
{
    int index = rcsToIndex((int3)(y, x, fSlice), fDim);
    return x <fDim.x && y < fDim.y / fDim.x && x >=0 && y >=0 ? (float2 )( filter[index],1 ): (float2)(0,0);
}

// fDim.x : nr of columns in the filter
// fDim.y : nr of rows in the filter.
// fDim.z : nr of rotations
__kernel void rotateKernels(
    const __constant float* filter,
    const int4 fDim,
    const __constant float2* sinCos,
    __global float* output
)
{
    int index = get_global_id(0);
    int2 filterSize=(int2)(fDim.y, fDim.x*fDim.y);
    int3 rcs = indexToRCS(index, filterSize );
    int nrOfRotations = fDim.z;
    // first slice is unrotated filter.
    int slice = rcs.z;
    int fSlice = slice / nrOfRotations;
    int currentRotation = slice % nrOfRotations; 

    float sa = sinCos[currentRotation].x;
    float ca = sinCos[currentRotation].y;
    
    float rcx = fDim.x / 2.0f;
    float rcy = fDim.y / 2.0f;

    float x = rcs.x;
    float y = rcs.y;
       
    float rx = x - rcx;
    float ry = y - rcy;

    float ox = rcx + rx * ca - ry * sa;
    float oy = rcy + rx * sa + ry * ca;

    float xPerc = fabs(fmod(ox, 1));
    float yPerc = fabs(fmod(oy, 1));
    int startx = (int) ox;
    int starty = (int) oy;
    
    float4 i;
    float4 mask;

    float2 i1 = getFilterValue(filter, startx,     starty     , fSlice, filterSize);
    float2 i2 = getFilterValue(filter, startx,     starty + 1 , fSlice, filterSize);
    float2 i3 = getFilterValue(filter, startx + 1, starty     , fSlice, filterSize);
    float2 i4 = getFilterValue(filter, startx + 1, starty + 1 , fSlice, filterSize);

    i.x = i1.x; mask.x = i1.y;
    i.y = i2.x; mask.y = i2.y;
    i.z = i3.x; mask.z = i3.y;
    i.w = i4.x; mask.w = i4.y;

    float4 a;
    a.x = (1 - xPerc) * (1 - yPerc);
    a.y = (1 - xPerc) * (yPerc);
    a.z = xPerc * (1 - yPerc);
    a.w = xPerc * yPerc;
    
    float renormSum = dot(a,mask);
    float div = fabs(renormSum) < 0.0001f? 1:renormSum;
    output[rcsToIndex( (int3)(rcs.y,rcs.x,slice), filterSize)] = dot(i,a) / div; 
}

float2 getRotatedValue( const __global float* rotated, int x, int y,int fSlice,  int2 fDim)
{
    int index = rcsToIndex((int3)(y, x, fSlice), fDim);
    return x <fDim.x && y < fDim.y / fDim.x && x >=0 && y >=0 ? (float2 )( rotated[index],1 ): (float2)(0,0);
}

// fDim.x : nr of columns in the filter
// fDim.y : nr of rows in the filter.
// fDim.z : nr of rotations
__kernel void accumulateRotateKernels(
    const __global float* rotatedOutput,
    const int4 fDim,
    const __constant float2* sinCos,
    __global float* kernelOutput
)
{
    int index = get_global_id(0);
    int2 filterSize=(int2)(fDim.y, fDim.x*fDim.y);
    int3 rcs = indexToRCS(index, filterSize );
    
    int slice = rcs.z;
    int nrOfRotations = fDim.z;

    for(int currentRotation = 0 ; currentRotation < nrOfRotations; ++currentRotation){
        int fSlice = rcs.z * nrOfRotations + currentRotation;
        float sa = sinCos[currentRotation].x;
        float ca = sinCos[currentRotation].y;

        float rcx = fDim.x / 2.0f;
        float rcy = fDim.y / 2.0f;

        float x = rcs.x;
        float y = rcs.y;

        float rx = x - rcx;
        float ry = y - rcy;

        float ox = rcx + rx * ca - ry * sa;
        float oy = rcy + rx * sa + ry * ca;

        float xPerc = fabs(fmod(ox, 1));
        float yPerc = fabs(fmod(oy, 1));
        int startx = (int) ox;
        int starty = (int) oy;

        float4 i;
        float4 mask;

        float2 i1 = getRotatedValue(rotatedOutput, startx,     starty     , fSlice, filterSize);
        float2 i2 = getRotatedValue(rotatedOutput, startx,     starty + 1 , fSlice, filterSize);
        float2 i3 = getRotatedValue(rotatedOutput, startx + 1, starty     , fSlice, filterSize);
        float2 i4 = getRotatedValue(rotatedOutput, startx + 1, starty + 1 , fSlice, filterSize);

        i.x = i1.x; mask.x = i1.y;
        i.y = i2.x; mask.y = i2.y;
        i.z = i3.x; mask.z = i3.y;
        i.w = i4.x; mask.w = i4.y;

        float4 a;
        a.x = (1 - xPerc) * (1 - yPerc);
        a.y = (1 - xPerc) * (yPerc);
        a.z = xPerc * (1 - yPerc);
        a.w = xPerc * yPerc;

        float renormSum = dot(a,mask);
        float div = fabs(renormSum) < 0.0001f? 1:renormSum;
        float result = dot(i,a) / div;
        kernelOutput[rcsToIndex( (int3)(rcs.y,rcs.x,slice), filterSize)] += result ; 
    }
}

// iDim: (x,y,z) rowSize, sliceSize, hyperSliceSize of input.
// oDim : (x,y,z) rowSize, sliceSize, hyperSliceSize of output.
// filterDesc : (x,y) slicePerFeature, nrOfRotations.
__kernel void maxRotation(
    const __global float* input,
    __global float* valOutput,
    __global float* rotOutput,
    const int3 iDim,
    const int3 oDim,
    const int3 desc,
    const float rotStepSize
)
{
    int index = get_global_id(0);
    int4 rcsh = indexToRCSH(index,oDim);

    int currentSlice = rcsh.z;
    int spf = desc.x;
    int nrOfRotations = desc.y;

    int feature = currentSlice / spf;
    int subslice = currentSlice % spf;
    
    float m = -1000000;
    float rot = 0;
    int baseSlice = feature * spf * nrOfRotations;
    for(int r = 0 ; r < nrOfRotations; ++r ){
        int inputIndex =  rcshToIndex((int4)(rcsh.x ,rcsh.y, baseSlice + r * spf +subslice, rcsh.w),iDim);
       
        float val = input[ min(inputIndex,desc.z) ];
        if ( val > m ){
            m = val;
            rot = r * rotStepSize;
        }
    }
    valOutput[index] = m;
    rotOutput[index] = rot;
}

// iDim: (x,y,z) rowSize, sliceSize, hyperSliceSize of input.
// oDim : (x,y,z) rowSize, sliceSize, hyperSliceSize of output.
// filterDesc : (x,y) slicePerFeature, nrOfRotations.
__kernel void inverseMaxRotation(
    __global float* valInput,
    __global float* rotInput,
    __global float* output,
    const int3 iDim,
    const int3 oDim,
    const int3 desc,
    const float rotStepSize
)
{
    int index = get_global_id(0);
    int4 rcsh = indexToRCSH(index,iDim);
    
    int currentSlice = rcsh.z;

    int spf = desc.x;
    int nrOfRotations = desc.y;

    int feature = currentSlice / spf;
    int subslice = currentSlice % spf;

    float value = valInput[index];
    float rotation = rotInput[index];

    int rotationIndex = round(rotation/rotStepSize);
    
    int oSlice = feature * spf * nrOfRotations +  rotationIndex *spf + subslice;
    int oIndex = rcshToIndex( (int4)(rcsh.x, rcsh.y, oSlice, rcsh.w),oDim);
    output[min(oIndex,desc.z)] = value;
}

// iDim: (x,y,z) rowSize, sliceSize, hyperSliceSize of input.
// oDim : (x,y,z) rowSize, sliceSize, hyperSliceSize of output.
// groups : (x,y) slicesPerGroup, nrOfBiases.
__kernel void forwardPancake(
    __global float* input,
    const int3 iDim,
    __global float* weights,
    const int3 wDim,
    __global float* output,
    const int3 oDim,
    const int2 groups
)
{
    int index = get_global_id(0);
    int4 rcsh = indexToRCSH(index, oDim);
    
    int slicesPerGroup = groups.x;
    int nrOfBiases = groups.y;

    int inputBaseSlice = rcsh.z * slicesPerGroup;
    int weightBaseSlice = rcsh.z * (slicesPerGroup+nrOfBiases);
    
    float sum = 0;
    
    for(int s = 0 ; s < slicesPerGroup; ++s ){
        int4 iRCSH = (int4)(rcsh.x, rcsh.y, inputBaseSlice + s, rcsh.w);
        int iIndex = rcshToIndex(iRCSH,iDim);
        int4 wRCSH = (int4)(rcsh.x, rcsh.y, weightBaseSlice + s, rcsh.w);
        int wIndex = rcshToIndex(wRCSH,wDim);

        sum += input[iIndex] * weights[wIndex];
    }
    for(int b = 0 ; b < nrOfBiases; b++)
    {
        int4 wRCSH = (int4)(rcsh.x, rcsh.y, inputBaseSlice + slicesPerGroup + b , rcsh.w);
        int wIndex = rcshToIndex(wRCSH,wDim);
        sum += weights[wIndex];
    }
    output[index] = sum;
}

// iDim: (x,y,z) rowSize, sliceSize, hyperSliceSize of input.
// oDim : (x,y,z) rowSize, sliceSize, hyperSliceSize of output.
// groups : (x,y) slicesPerGroup, nrOfBiases.
__kernel void deltasPancake(
    __global float* input,
    const int3 iDim,
    __global float* deltas,
    const int3 wDim,
    __global float* deltaWeights,
    const int3 oDim,
    const int2 groups
)
{
    int index = get_global_id(0);
    int4 rcsh = indexToRCSH(index, oDim);
    
    
    deltaWeights[index] = 0;
}